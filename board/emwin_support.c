/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
//#include "FreeRTOS.h"
//#include "task.h"
//#include "queue.h"
//#include "timers.h"
//#include "semphr.h"
#include "GUI.h"
#include "WM.h"
#include "GUIDRV_Lin.h"
#include "board.h"
#include "fsl_ctimer.h"
#include "fsl_sctimer.h"
#include "fsl_gpio.h"
#include "fsl_lcdc.h"


#include <cr_section_macros.h>


#include "fsl_device_registers.h"
#include "pin_mux.h"
#include "board.h"
#include "stdint.h"

#include "DIALOG.h"


#include "GUI.h"


#include "stdio.h"
#include "stdlib.h"
#include "fsl_ctimer.h"
#include "fsl_sctimer.h"


#include <stdio.h>
#include "board.h"
#include "pin_mux.h"
#include "clock_config.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "board.h"
#include "fsl_lcdc.h"


#include "fsl_gpio.h"
#include <cr_section_macros.h>

#include "pin_mux.h"
#include "fsl_sctimer.h"
#include "fsl_ctimer.h"




#include "fsl_power.h"







#include "GUIDRV_FlexColor.h"
/* Frame end flag. */
///#define  GUI_NUMBYTES    0x40000
#define GUI_MEM_ADDR   0xA0000000
#define VRAM_ADDR      0xA02EE000
#define GUI_BLOCKSIZE    0x128
//#define CTIMER CTIMER3
#define VRAM_SIZE  (960000)
static volatile int32_t s_LCDpendingBuffer = -1;
//touch_event_t touch_event;
GUI_PID_STATE pid_state;


//static SemaphoreHandle_t xQueueMutex;
//static SemaphoreHandle_t xSemaTxDone;

///extern  uint32_t GUI_memBuff[GUI_NUMBYTES/4];
//__attribute__(( section(".noinit.$RAM4"), aligned(16))) uint16_t GUI_memBuff[GUI_NUMBYTES/4];
//extern uint16_t *0;
// create a zero-init buffer in RAM2
//__BSS(RAM4) uint32_t GuimemBuff[GUI_NUMBYTES] ;
 //uint16_t 0[800][600] ;
//uint16_t s_frameBuf0[800][600] __attribute__((at(0xA0040000))) ; /* RW */
//__BSS(RAM4) uint32_t s_frameBuf0[800][600] ; // create a zero-init buffer in RAM2
//extern uint16_t GuimemoryBuffer[65536];
//extern uint16_t GuimemoryBuffer[GUI_NUMBYTES/4];
//static U32 GuimemoryBuffer[GUI_NUMBYTES / 4] __attribute__((at(0xA0100000)));
//__attribute__ (( aligned(16),section(".noinit.$RAM4"))) uint16_t GuimemoryBuffer[GUI_NUMBYTES/4];
//__attribute__ (( aligned(16),section(".noinit.$RAM5"))) static uint16_t GuimemoryBuffer[GUI_NUMBYTES];
//extern uint16_t s_frameBuf0[480000] ;
//extern uint16_t* GuimemoryBuffer;
/*********************************************************************
*            (c) 1998 - 2019 Segger Microcontroller GmbH             *
*        Solutions for real time microcontroller applications        *
*                           www.segger.com                           *
**********************************************************************
*                                                                    *
* C-file generated by                                                *
*                                                                    *
*        Bitmap Converter for emWin (Demo version) V6.20.            *
*        Compiled Aug 13 2021, 11:07:23                              *
*                                                                    *
*        (c) 1998 - 2019 Segger Microcontroller GmbH                 *
*                                                                    *
*        May not be used in a product                                *
*                                                                    *
**********************************************************************
*                                                                    *
* Source file: parrots                                               *
* Dimensions:  384 * 256                                             *
* NumColors:   16bpp: 65536                                          *
* NumBytes:    196628                                                *
*                                                                    *
**********************************************************************
*/

#include "board.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "LPC54618.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "board.h"
#include "fsl_lcdc.h"
#include "fsl_gpio.h"
#include <cr_section_macros.h>
#include "pin_mux.h"
#include "fsl_ctimer.h"
#include "fsl_power.h"


#include "GUI.h"
#include "LCD.h"
#include "WM.h"
#include "stdint.h"

/*************************** End of file ****************************/
 //unsigned int  GuiNumberofBytes[GUI_NUMBYTES/4] __attribute__((section(".noinit.$RAM")));
 //unsigned int  V_RamframeBuff[480000]           __attribute__((section(".noinit.$RAM4")));

///__attribute__(( section(".noinit.$RAM4"), aligned(16)))unsigned int  DischargePatientarr[ID_DPW_NAVIGATION_TOTAL_NAVIGATABLE_WIDGETS][2]  ;
extern  unsigned char   GuiNumberofBytes[GUI_NUMBYTES/4];
extern unsigned int   V_RamframeBuff[480000];




///__attribute__ ((aligned(16), section(".noinit.$RAM10")))    unsigned short  GuiNumberofBytes[GUI_NUMBYTES/4]={0};
///__attribute__ ((aligned(16), section(".noinit.$RAM4")))    unsigned short  V_RamframeBuff[480000]={0};
/*******************************************************************************
 * Code
 ******************************************************************************/
void APP_LCD_IRQHandler(void)
{

    uint32_t intStatus = LCDC_GetEnabledInterruptsPendingStatus(APP_LCD);

    LCDC_ClearInterruptsStatus(APP_LCD, intStatus);

    if (intStatus & kLCDC_VerticalCompareInterrupt)
    {
    	//#include "fsl_common.h"
        if (s_LCDpendingBuffer >= 0)
        {
        	 //USART_WriteByte(NIBP_USART,'X');
            /* Send a confirmation that the given buffer is visible */
            GUI_MULTIBUF_Confirm(s_LCDpendingBuffer);
            s_LCDpendingBuffer = -1;
        }
    }
    __DSB();
}



/*******************************************************************************
 * Implementation of communication with the touch controller
 ******************************************************************************/

/* Touch driver handle. */
//static ft5406_handle_t touch_handle;


/*******************************************************************************
 * Application implemented functions required by emWin library
 ******************************************************************************/
void LCD_X_Config(void)
{

	char xtz[10];
	int val1=0,val2=0,val3=0;

    status_t status;
   //USART_WriteByte(NIBP_USART,'5');//USART_WriteByte(NIBP_USART,'6');
    GUI_MULTIBUF_Config(1);
   //USART_WriteByte(NIBP_USART,'7');//USART_WriteByte(NIBP_USART,'8');

   // GUI_MULTIBUF_Config(1);
    if(GUI_DEVICE_CreateAndLink(GUIDRV_LIN_16/*GUIDRV_LIN_16*/, GUICC_M565, 0, 0))
    {
       //USART_WriteByte(NIBP_USART,'N');//USART_WriteByte(NIBP_USART,'U');
    }
    else
    {
        //USART_WriteByte(NIBP_USART,'S');//USART_WriteByte(NIBP_USART,'U');
    }

    val1=LCD_SetSizeEx(0, 800, 600);
    sprintf(xtz,"%d",val1);
    //USART_WriteByte(NIBP_USART,xtz[0]);//USART_WriteByte(NIBP_USART,xtz[1]);
    //USART_WriteByte(NIBP_USART,'K');//USART_WriteByte(NIBP_USART,'1');
   // for(i=0;i<2000;i++){}
   val2=LCD_SetVSizeEx(0, 800, 600);
    sprintf(xtz,"%d",val2);
    //USART_WriteByte(NIBP_USART,xtz[0]);//USART_WriteByte(NIBP_USART,xtz[1]);

    //USART_WriteByte(NIBP_USART,'K');//USART_WriteByte(NIBP_USART,'2');
    //  for(i=0;i<2000;i++){}
    val3=LCD_SetVRAMAddrEx(0, (void *)V_RamframeBuff);
    sprintf(xtz,"%d",val3);

  assert(status == kStatus_Success);
}


int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void *p)
{
    GUI_USE_PARA(LayerIndex);
    char xtz[5];
    uint32_t addr;
    status_t status;
    int r = 0;
    LCD_X_SHOWBUFFER_INFO *pData=0;
     sprintf(xtz,"%d",Cmd);
     //USART_WriteByte(NIBP_USART,xtz[0]);//USART_WriteByte(NIBP_USART,xtz[1]);
    // //USART_WriteByte(NIBP_USART,xtz[2]);//USART_WriteByte(NIBP_USART,xtz[3]);


     switch (Cmd)
    {
        case LCD_X_INITCONTROLLER:
        {
            //USART_WriteByte(NIBP_USART,'*');
//            /* Initialize LCD controller */
          status = APP_LCDC_Init();
           if (status != kStatus_Success)
            {
            	//USART_WriteByte(NIBP_USART,'#');
               /// PRINTF("LCD init failed\n");
           }
//            ////USART_WriteByte(NIBP_USART,'~');
         //   assert(status == kStatus_Success);
           break;
        }
        case LCD_X_SHOWBUFFER:
        {

            pData = (LCD_X_SHOWBUFFER_INFO *)p;
            /* Calculate address of the given buffer */
            addr = V_RamframeBuff + VRAM_SIZE * pData->Index;
            /* Make the given buffer visible */
            LCDC_SetPanelAddr(APP_LCD, kLCDC_UpperPanel, addr);
            //
            // Remember buffer index to be used by ISR
            //
            s_LCDpendingBuffer = pData->Index;
            while (s_LCDpendingBuffer >= 0)
                ;
            return 0;
        }
//        case LCD_X_SETSIZE:
//        {
//				r=-1;
//				break;
//        }
        default:
            r = -1;
    }
    return r;
}

void GUI_X_Config(void)
{
	int i=0,j=0;
	char xyz[10];
	//uint16_t *MemoryBuff;
     unsigned char* temp=0;
	//Note that the low three bits 2:0 must be zero, so the pointer must be uint64_t type.



for(i=0;i<GUI_NUMBYTES;i++)
{
	GuiNumberofBytes[i]=0;

}


GUI_ALLOC_AssignMemory((unsigned long long*)GuiNumberofBytes, GUI_NUMBYTES);

    /* Select default font */
    GUI_SetDefaultFont(GUI_FONT_6X8);

}

void GUI_X_Init(void)
{

}

/*********************************************************************
*
*      Multitasking:
*
*                 GUI_X_InitOS()
*                 GUI_X_GetTaskId()
*                 GUI_X_Lock()
*                 GUI_X_Unlock()
*
* Note:
*   The following routines are required only if emWin is used in a
*   true multi task environment, which means you have more than one
*   thread using the emWin API.
*   In this case the
*                       #define GUI_OS  (1)
*  needs to be in GUIConf.h
*/

/*! @brief Init OS.Creates the resource semaphore or mutex typically used by GUI_X_Lock() and GUI_X_Unlock().*/
void GUI_X_InitOS(void)
{

	/* Create a Mutex lock*/
	//  xQueueMutex = xSemaphoreCreateMutex();
   //	configASSERT(xQueueMutex !=NULL);

	//  vSemaphoreCreateBinary(xSemaTxDone);
   //	configASSERT(xSemaTxDone != NULL);

}

/*! @brief Locks the GUI*/
void GUI_X_Lock(void)
{
	////USART_WriteByte(NIBP_USART,'O');//USART_WriteByte(NIBP_USART,'S');
	//xSemaphoreTake(xQueueMutex , portMAX_DELAY);
	////USART_WriteByte(NIBP_USART,'1');//USART_WriteByte(NIBP_USART,'2');
}

/*! @brief Unlocks the GUI */
void GUI_X_Unlock(void)
{

	//  xSemaphoreGive(xQueueMutex);
	////USART_WriteByte(NIBP_USART,'1');//USART_WriteByte(NIBP_USART,'3');
}

/*! @brief Get the Task handle */
U32 GUI_X_GetTaskId(void)
{
	 return 0;
   // return ((uint32_t)xTaskGetCurrentTaskHandle());
}


void GUI_X_ExecIdle(void)
{
	 GUI_X_Delay(1);
}

GUI_TIMER_TIME GUI_X_GetTime(void)
{
	 return CTIMER_GetTimerCountValue(CTIMER);

}

/*! @brief Returns after a specified time period in milliseconds. */
void GUI_X_Delay(int Period)
{
	int i=0;
    volatile uint32_t tNow = CTIMER_GetTimerCountValue(CTIMER);
    while ((CTIMER_GetTimerCountValue(CTIMER) - tNow) < Period)
       ;
//	for(i=0;i<Period*100;i++){}
}

void *emWin_memcpy(void *pDst, const void *pSrc, long size)
{
    return memcpy(pDst, pSrc, size);
}
status_t APP_LCDC_Init(void)
{
    // Initialize the display.
    lcdc_config_t lcdConfig;
//    lcdc_cursor_config_t cursorConfig;
    LCDC_GetDefaultConfig(&lcdConfig);
    lcdConfig.panelClock_Hz = LCD_PANEL_CLK;
    lcdConfig.ppl = LCD_PPL;
    lcdConfig.hsw = LCD_HSW; //LCD_HSW;
    lcdConfig.hfp = LCD_HFP;
    lcdConfig.hbp = LCD_HBP;
    lcdConfig.lpp = LCD_LPP;
    lcdConfig.vsw = LCD_VSW;
    lcdConfig.vfp = LCD_VFP;
    lcdConfig.vbp = LCD_VBP;
    lcdConfig.polarityFlags = LCD_POL_FLAGS;
    lcdConfig.upperPanelAddr = (unsigned int)V_RamframeBuff;
    lcdConfig.bpp = kLCDC_16BPP565;
    lcdConfig.display = kLCDC_DisplayTFT;
    lcdConfig.swapRedBlue = true;
    lcdConfig.dataFormat = kLCDC_LittleEndian;
    LCDC_Init(APP_LCD, &lcdConfig, LCD_INPUT_CLK_FREQ);

    /* Trigger interrupt at start of every vertical back porch. */
    LCDC_SetVerticalInterruptMode(APP_LCD, kLCDC_StartOfVsync);
    LCDC_EnableInterrupts(APP_LCD, kLCDC_VerticalCompareInterrupt);
    NVIC_EnableIRQ(APP_LCD_IRQn);

    LCDC_Start(APP_LCD);
    LCDC_PowerUp(APP_LCD);

    return kStatus_Success;
}

